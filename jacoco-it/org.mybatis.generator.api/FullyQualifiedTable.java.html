<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FullyQualifiedTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">MyBatis Generator Core</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.generator.api</a> &gt; <span class="el_source">FullyQualifiedTable.java</span></div><h1>FullyQualifiedTable.java</h1><pre class="source lang-java linenums">/**
 *    Copyright 2006-2018 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.generator.api;

import static org.mybatis.generator.internal.util.EqualsUtil.areEqual;
import static org.mybatis.generator.internal.util.HashCodeUtil.SEED;
import static org.mybatis.generator.internal.util.HashCodeUtil.hash;
import static org.mybatis.generator.internal.util.JavaBeansUtil.getCamelCaseString;
import static org.mybatis.generator.internal.util.StringUtility.composeFullyQualifiedTableName;
import static org.mybatis.generator.internal.util.StringUtility.stringHasValue;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.mybatis.generator.config.Context;
import org.mybatis.generator.config.DomainObjectRenamingRule;

/**
 * The Class FullyQualifiedTable.
 *
 * @author Jeff Butler
 */
public class FullyQualifiedTable {

    private String introspectedCatalog;
    private String introspectedSchema;
    private String introspectedTableName;
    private String runtimeCatalog;
    private String runtimeSchema;
    private String runtimeTableName;
    private String domainObjectName;
    private String domainObjectSubPackage;
    private String alias;
    private boolean ignoreQualifiersAtRuntime;
    private String beginningDelimiter;
    private String endingDelimiter;
    private DomainObjectRenamingRule domainObjectRenamingRule;

    /**
     * This object is used to hold information related to the table itself, not the columns in the
     * table.
     *
     * @param introspectedCatalog
     *            the actual catalog of the table as returned from DatabaseMetaData. This value
     *            should only be set if the user configured a catalog. Otherwise the
     *            DatabaseMetaData is reporting some database default that we don't want in the
     *            generated code.
     * @param introspectedSchema
     *            the actual schema of the table as returned from DatabaseMetaData. This value
     *            should only be set if the user configured a schema. Otherwise the
     *            DatabaseMetaData is reporting some database default that we don't want in the
     *            generated code.
     * @param introspectedTableName
     *            the actual table name as returned from DatabaseMetaData
     * @param domainObjectName
     *            the configured domain object name for this table. If nothing is configured, we'll build the domain
     *            object named based on the tableName or runtimeTableName.
     * @param alias
     *            a configured alias for the table. This alias will be added to the table name in the SQL
     * @param ignoreQualifiersAtRuntime
     *            if true, then the catalog and schema qualifiers will be ignored when composing fully qualified names
     *            in the generated SQL. This is used, for example, when the user needs to specify a specific schema for
     *            generating code but does not want the schema in the generated SQL
     * @param runtimeCatalog
     *            this is used to &quot;rename&quot; the catalog in the generated SQL. This is useful, for example, when
     *            generating code against one catalog that should run with a different catalog.
     * @param runtimeSchema
     *            this is used to &quot;rename&quot; the schema in the generated SQL. This is useful, for example, when generating
     *            code against one schema that should run with a different schema.
     * @param runtimeTableName
     *            this is used to &quot;rename&quot; the table in the generated SQL. This is useful, for example, when generating
     *            code to run with an Oracle synonym. The user would have to specify the actual table name and schema
     *            for generation, but would want to use the synonym name in the generated SQL
     * @param delimitIdentifiers
     *            if true, then the table identifiers will be delimited at runtime. The delimiter characters are
     *            obtained from the Context.
     * @param domainObjectRenamingRule
     *            If domainObjectName is not configured, we'll build the domain object named based on the tableName or runtimeTableName.
     *            And then we use the domain object renaming rule to generate the final domain object name.
     * @param context
     *            the context
     */
    public FullyQualifiedTable(String introspectedCatalog,
            String introspectedSchema, String introspectedTableName,
            String domainObjectName, String alias,
            boolean ignoreQualifiersAtRuntime, String runtimeCatalog,
            String runtimeSchema, String runtimeTableName,
            boolean delimitIdentifiers, DomainObjectRenamingRule domainObjectRenamingRule,
            Context context) {
<span class="fc" id="L103">        super();</span>
<span class="fc" id="L104">        this.introspectedCatalog = introspectedCatalog;</span>
<span class="fc" id="L105">        this.introspectedSchema = introspectedSchema;</span>
<span class="fc" id="L106">        this.introspectedTableName = introspectedTableName;</span>
<span class="fc" id="L107">        this.ignoreQualifiersAtRuntime = ignoreQualifiersAtRuntime;</span>
<span class="fc" id="L108">        this.runtimeCatalog = runtimeCatalog;</span>
<span class="fc" id="L109">        this.runtimeSchema = runtimeSchema;</span>
<span class="fc" id="L110">        this.runtimeTableName = runtimeTableName;</span>
<span class="fc" id="L111">        this.domainObjectRenamingRule = domainObjectRenamingRule;</span>

<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (stringHasValue(domainObjectName)) {</span>
<span class="fc" id="L114">            int index = domainObjectName.lastIndexOf('.');</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (index == -1) {</span>
<span class="fc" id="L116">                this.domainObjectName = domainObjectName;</span>
            } else {
<span class="fc" id="L118">                this.domainObjectName = domainObjectName.substring(index + 1);</span>
<span class="fc" id="L119">                this.domainObjectSubPackage = domainObjectName.substring(0, index);</span>
            }
        }

<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (alias == null) {</span>
<span class="fc" id="L124">            this.alias = null;</span>
        } else {
<span class="fc" id="L126">            this.alias = alias.trim();</span>
        }

<span class="fc bfc" id="L129" title="All 2 branches covered.">        beginningDelimiter = delimitIdentifiers ? context</span>
<span class="fc" id="L130">                .getBeginningDelimiter() : &quot;&quot;; //$NON-NLS-1$</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        endingDelimiter = delimitIdentifiers ? context.getEndingDelimiter()</span>
                : &quot;&quot;; //$NON-NLS-1$
<span class="fc" id="L133">    }</span>

    /**
     * Gets the introspected catalog.
     *
     * @return the introspected catalog
     */
    public String getIntrospectedCatalog() {
<span class="fc" id="L141">        return introspectedCatalog;</span>
    }

    /**
     * Gets the introspected schema.
     *
     * @return the introspected schema
     */
    public String getIntrospectedSchema() {
<span class="fc" id="L150">        return introspectedSchema;</span>
    }

    /**
     * Gets the introspected table name.
     *
     * @return the introspected table name
     */
    public String getIntrospectedTableName() {
<span class="fc" id="L159">        return introspectedTableName;</span>
    }

    /**
     * Gets the fully qualified table name at runtime.
     *
     * @return the fully qualified table name at runtime
     */
    public String getFullyQualifiedTableNameAtRuntime() {
<span class="fc" id="L168">        StringBuilder localCatalog = new StringBuilder();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (!ignoreQualifiersAtRuntime) {</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            if (stringHasValue(runtimeCatalog)) {</span>
<span class="nc" id="L171">                localCatalog.append(runtimeCatalog);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">            } else if (stringHasValue(introspectedCatalog)) {</span>
<span class="nc" id="L173">                localCatalog.append(introspectedCatalog);</span>
            }
        }
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        if (localCatalog.length() &gt; 0) {</span>
<span class="nc" id="L177">            addDelimiters(localCatalog);</span>
        }

<span class="fc" id="L180">        StringBuilder localSchema = new StringBuilder();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (!ignoreQualifiersAtRuntime) {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            if (stringHasValue(runtimeSchema)) {</span>
<span class="nc" id="L183">                localSchema.append(runtimeSchema);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            } else if (stringHasValue(introspectedSchema)) {</span>
<span class="fc" id="L185">                localSchema.append(introspectedSchema);</span>
            }
        }
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (localSchema.length() &gt; 0) {</span>
<span class="fc" id="L189">            addDelimiters(localSchema);</span>
        }

<span class="fc" id="L192">        StringBuilder localTableName = new StringBuilder();</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (stringHasValue(runtimeTableName)) {</span>
<span class="nc" id="L194">            localTableName.append(runtimeTableName);</span>
        } else {
<span class="fc" id="L196">            localTableName.append(introspectedTableName);</span>
        }
<span class="fc" id="L198">        addDelimiters(localTableName);</span>

<span class="fc" id="L200">        return composeFullyQualifiedTableName(localCatalog</span>
<span class="fc" id="L201">                .toString(), localSchema.toString(), localTableName.toString(),</span>
                '.');
    }

    /**
     * Gets the aliased fully qualified table name at runtime.
     *
     * @return the aliased fully qualified table name at runtime
     */
    public String getAliasedFullyQualifiedTableNameAtRuntime() {
<span class="fc" id="L211">        StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L213">        sb.append(getFullyQualifiedTableNameAtRuntime());</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (stringHasValue(alias)) {</span>
<span class="fc" id="L216">            sb.append(' ');</span>
<span class="fc" id="L217">            sb.append(alias);</span>
        }

<span class="fc" id="L220">        return sb.toString();</span>
    }

    /**
     * Returns a string that is the fully qualified table name, with
     * underscores as the separator.
     * 
     * @return the namespace
     */
    public String getIbatis2SqlMapNamespace() {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        String localCatalog = stringHasValue(runtimeCatalog) ? runtimeCatalog</span>
                : introspectedCatalog;
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        String localSchema = stringHasValue(runtimeSchema) ? runtimeSchema</span>
                : introspectedSchema;
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        String localTable = stringHasValue(runtimeTableName) ? runtimeTableName</span>
                : introspectedTableName;

<span class="pc bpc" id="L237" title="2 of 4 branches missed.">        return composeFullyQualifiedTableName(</span>
                        ignoreQualifiersAtRuntime ? null : localCatalog,
                        ignoreQualifiersAtRuntime ? null : localSchema,
                        localTable, '_');
    }

    /**
     * Gets the domain object name.
     *
     * @return the domain object name
     */
    public String getDomainObjectName() {
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (stringHasValue(domainObjectName)) {</span>
<span class="fc" id="L250">            return domainObjectName;</span>
        }

        String finalDomainObjectName;
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (stringHasValue(runtimeTableName)) {</span>
<span class="nc" id="L255">            finalDomainObjectName =  getCamelCaseString(runtimeTableName, true);</span>
        } else {
<span class="fc" id="L257">            finalDomainObjectName =  getCamelCaseString(introspectedTableName, true);</span>
        }

<span class="fc bfc" id="L260" title="All 2 branches covered.">        if (domainObjectRenamingRule != null) {</span>
<span class="fc" id="L261">            Pattern pattern = Pattern.compile(domainObjectRenamingRule.getSearchString());</span>
<span class="fc" id="L262">            String replaceString = domainObjectRenamingRule.getReplaceString();</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            replaceString = replaceString == null ? &quot;&quot; : replaceString; //$NON-NLS-1$</span>
<span class="fc" id="L264">            Matcher matcher = pattern.matcher(finalDomainObjectName);</span>
<span class="fc" id="L265">            finalDomainObjectName = getCamelCaseString(matcher.replaceAll(replaceString), true);</span>
        }
<span class="fc" id="L267">        return finalDomainObjectName;</span>
    }

    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L276">            return true;</span>
        }

<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (!(obj instanceof FullyQualifiedTable)) {</span>
<span class="nc" id="L280">            return false;</span>
        }

<span class="nc" id="L283">        FullyQualifiedTable other = (FullyQualifiedTable) obj;</span>

<span class="nc bnc" id="L285" title="All 2 branches missed.">        return areEqual(this.introspectedTableName,</span>
                other.introspectedTableName)
<span class="nc bnc" id="L287" title="All 2 branches missed.">                &amp;&amp; areEqual(this.introspectedCatalog,</span>
                        other.introspectedCatalog)
<span class="nc bnc" id="L289" title="All 2 branches missed.">                &amp;&amp; areEqual(this.introspectedSchema,</span>
                        other.introspectedSchema);
    }

    /* (non-Javadoc)
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
<span class="fc" id="L298">        int result = SEED;</span>
<span class="fc" id="L299">        result = hash(result, introspectedTableName);</span>
<span class="fc" id="L300">        result = hash(result, introspectedCatalog);</span>
<span class="fc" id="L301">        result = hash(result, introspectedSchema);</span>

<span class="fc" id="L303">        return result;</span>
    }

    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
<span class="fc" id="L311">        return composeFullyQualifiedTableName(</span>
                introspectedCatalog, introspectedSchema, introspectedTableName,
                '.');
    }

    /**
     * Gets the alias.
     *
     * @return the alias
     */
    public String getAlias() {
<span class="nc" id="L322">        return alias;</span>
    }

    /**
     * Calculates a Java package fragment based on the table catalog and schema.
     * If qualifiers are ignored, then this method will return an empty string.
     * 
     * &lt;p&gt;This method is used for determining the sub package for Java client and
     * SQL map (XML) objects.  It ignores any sub-package added to the
     * domain object name in the table configuration.
     *
     * @param isSubPackagesEnabled
     *            the is sub packages enabled
     * @return the subpackage for this table
     */
    public String getSubPackageForClientOrSqlMap(boolean isSubPackagesEnabled) {
<span class="fc" id="L338">        StringBuilder sb = new StringBuilder();</span>
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">        if (!ignoreQualifiersAtRuntime &amp;&amp; isSubPackagesEnabled) {</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">            if (stringHasValue(runtimeCatalog)) {</span>
<span class="nc" id="L341">                sb.append('.');</span>
<span class="nc" id="L342">                sb.append(runtimeCatalog.toLowerCase());</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            } else if (stringHasValue(introspectedCatalog)) {</span>
<span class="nc" id="L344">                sb.append('.');</span>
<span class="nc" id="L345">                sb.append(introspectedCatalog.toLowerCase());</span>
            }

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (stringHasValue(runtimeSchema)) {</span>
<span class="nc" id="L349">                sb.append('.');</span>
<span class="nc" id="L350">                sb.append(runtimeSchema.toLowerCase());</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">            } else if (stringHasValue(introspectedSchema)) {</span>
<span class="fc" id="L352">                sb.append('.');</span>
<span class="fc" id="L353">                sb.append(introspectedSchema.toLowerCase());</span>
            }
        }

        // TODO - strip characters that are not valid in package names
<span class="fc" id="L358">        return sb.toString();</span>
    }

    /**
     * Calculates a Java package fragment based on the table catalog and schema.
     * If qualifiers are ignored, then this method will return an empty string.
     * 
     * &lt;p&gt;This method is used for determining the sub package for Java model objects only.
     * It takes into account the possibility that a sub-package was added to the
     * domain object name in the table configuration.
     *
     * @param isSubPackagesEnabled
     *            the is sub packages enabled
     * @return the subpackage for this table
     */
    public String getSubPackageForModel(boolean isSubPackagesEnabled) {
<span class="fc" id="L374">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L375">        sb.append(getSubPackageForClientOrSqlMap(isSubPackagesEnabled));</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (stringHasValue(domainObjectSubPackage)) {</span>
<span class="fc" id="L378">            sb.append('.');</span>
<span class="fc" id="L379">            sb.append(domainObjectSubPackage);</span>
        }

<span class="fc" id="L382">        return sb.toString();</span>
    }

    /**
     * Adds the delimiters.
     *
     * @param sb
     *            the sb
     */
    private void addDelimiters(StringBuilder sb) {
<span class="fc bfc" id="L392" title="All 2 branches covered.">        if (stringHasValue(beginningDelimiter)) {</span>
<span class="fc" id="L393">            sb.insert(0, beginningDelimiter);</span>
        }

<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (stringHasValue(endingDelimiter)) {</span>
<span class="fc" id="L397">            sb.append(endingDelimiter);</span>
        }
<span class="fc" id="L399">    }</span>

    public String getDomainObjectSubPackage() {
<span class="fc" id="L402">        return domainObjectSubPackage;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>